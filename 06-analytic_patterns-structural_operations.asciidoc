=== Grouping Operations

==== Find Aggregate Statistics of a Group

----
SELECT
  teamID, COUNT(*) AS n_seasons, MIN(yearID) as yearBeg, MAX(yearID) as yearEnd
  FROM teams tm
  GROUP BY teamID
  ORDER BY n_seasons DESC, teamID ASC
;
----

-- Group on year; find COUNT(), count distinct, MIN(), MAX(), SUM(), AVG(), STDEV(), byte size

SELECT
    MIN(HR)              AS hr_min,
    MAX(HR)              AS hr_max,
    AVG(HR)              AS hr_avg,
    STDDEV_POP(HR)       AS hr_stddev,
    SUM(HR)              AS hr_sum,
    COUNT(*)             AS n_recs,
    COUNT(*) - COUNT(HR) AS hr_n_nulls,
    COUNT(DISTINCT HR)   AS hr_n_distinct -- doesn't count NULL
  FROM bat_season bat
;

SELECT
    MIN(nameFirst)                     AS nameFirst_min,
    MAX(nameFirst)                     AS nameFirst_max,
    --
    MIN(CHAR_LENGTH(nameFirst))        AS nameFirst_strlen_min,
    MAX(CHAR_LENGTH(nameFirst))        AS nameFirst_strlen_max,
    MIN(OCTET_LENGTH(nameFirst))       AS nameFirst_bytesize_max,
    MAX(OCTET_LENGTH(nameFirst))       AS nameFirst_bytesize_max,
    AVG(CHAR_LENGTH(nameFirst))        AS nameFirst_strlen_avg,
    STDDEV_POP(CHAR_LENGTH(nameFirst)) AS nameFirst_strlen_stddev,
    LEFT(GROUP_CONCAT(nameFirst),25)   AS nameFirst_examples,
    SUM(CHAR_LENGTH(nameFirst))        AS nameFirst_strlen_sum,
    --
    COUNT(*)                           AS n_recs,
    COUNT(*) - COUNT(nameFirst)        AS nameFirst_n_nulls,
    COUNT(DISTINCT nameFirst)          AS nameFirst_n_distinct
  FROM bat_career bat
;

SELECT
  playerID,
  MIN(yearID) AS yearBeg,
  MAX(yearID) AS yearEnd,
  COUNT(*)    AS n_years,
    MIN(HR)              AS hr_min,
    MAX(HR)              AS hr_max,
    AVG(HR)              AS hr_avg,
    STDDEV_POP(HR)       AS hr_stddev,
    SUM(HR)              AS hr_sum,
    COUNT(*)             AS n_recs,
    COUNT(*) - COUNT(HR) AS hr_n_nulls,
    COUNT(DISTINCT HR)   AS hr_n_distinct -- doesn't count NULL
  FROM bat_season bat
  GROUP BY playerID
  ORDER BY hr_max DESC
;

-- Count seasons per team
SELECT
  teamID, COUNT(*) AS n_seasons, MIN(yearID) as yearBeg, MAX(yearID) as yearEnd
  FROM teams tm
  GROUP BY teamID
  ORDER BY n_seasons DESC, teamID ASC
;



Finding a median (or other quantiles) is quite difficult at large scale; we'll discuss why and what to do about it in the Statistics chapter (REF).
==== Distribution of Values Using a Histogram

Histogram of Hits per season

SELECT
  10 * CEIL(H/10), COUNT(*) AS n_H
  FROM bat_season bat
  GROUP BY SB
  ORDER BY SB DESC
;

In this case, we knew what bins to apply.

=== Putting tables in context with JOIN and friends

==== Direct Join: Extend Records with Uniquely Matching Records from Another Table

hang weight, height and BMI off of their OPS (overall hitting); ISO ("isolated power");
and number of stolen bases per time on base (loosely tied to speed)

SELECT bat.playerID, peep.nameCommon, begYear,
    peep.weight, peep.height,
    703*peep.weight/(peep.height*peep.height) AS BMI, -- measure of body type
    PA, OPS, ISO
  FROM bat_career bat
  JOIN people peep ON bat.playerID = peep.playerID
  WHERE PA > 500 AND begYear > 1910
  ORDER BY BMI DESC
  ;

(add note) Joins on null values are dropped even when both are null. Filter nulls. (I can't come up with a good example of this)
(add note) in contrast, all elements with null in a group _will_ be grouped as null. This can be dangerous when large number of nulls: all go to same reducer

-- don't do this (needs two group-bys):
SELECT n_seasons, COUNT(*), COUNT(*)/n_seasons
  FROM (SELECT COUNT(*) AS n_seasons FROM batting) t1,
  (SELECT COUNT(*) AS n_stints FROM batting GROUP BY playerID, yearID HAVING n_stints > 1) stintful
  ;
-- instead use the summing trick (needs only one group-by):
SELECT COUNT(*), (COUNT(*)-SUM(IF(stint = 1, 1, 0)))/COUNT(*), COUNT(*) FROM batting WHERE stint <= 2;



==== Fill in Holes in a List with a Join on an integer table

If we prepare a histogram of career hits, similar to the one above for seasons, you'll find that Pete Rose (4256 hits) and Ty Cobb (4189 hits) have so many more hits than the third-most player (Hank Aaron, 3771 hits) there are gaps in the output bins. To make it so that every bin has an entry, we can join on the integer table:


----
SET @Hbsz = 10;
SELECT bin, H, IFNULL(n_H,0)
  FROM      (SELECT @Hbsz * idx AS bin FROM numbers WHERE idx <= 430) nums
  LEFT JOIN (SELECT @Hbsz*CEIL(H/@Hbsz) AS H, COUNT(*) AS n_H
    FROM bat_career bat GROUP BY H) hist
  ON hist.H = nums.bin
  ORDER BY bin DESC
;
----

Comparing a Table to Itself (Self-join)

-- teammates (played for same team same season, discarding second and later
-- stints; players half table?)  note that we're cheating a bit: players may
-- change teams during the season (happens in about 7% of player seasons). We're
-- only going to use the first stint of a season.

-- need to do this off combined table (batting only right now)
SELECT b1.playerID, b2.playerID, b1.nameCommon, b2.nameCommon, b1.teamID, b1.yearID
  FROM bat_war b1, bat_war b2
  WHERE b1.teamID = b2.teamID          -- same team
    AND b1.yearID = b2.yearID          -- same season
    AND b1.stint = 1 AND b2.stint = 1  -- don't match players to multiple teams per year
    AND b1.playerID != b2.playerID     -- reject self-teammates
  ORDER BY yearID DESC, teamID ASC, b1.playerID ASC

-- note the explosion: 90k player-seasons lead to 3,104,324 teammate-year pairs.
-- the distinct pairing is 2 million

SELECT DISTINCT b1.playerID, b2.playerID, b1.nameCommon, b2.nameCommon
  FROM bat_war b1, bat_war b2
  WHERE b1.teamID = b2.teamID          -- same team
    AND b1.yearID = b2.yearID          -- same season
    AND b1.stint = 1 AND b2.stint = 1  -- don't match players to multiple teams per year
    AND b1.playerID != b2.playerID     -- reject self-teammates
  ORDER BY b1.playerID ASC, b2.playerID ASC
  ;

-- Grouping the teammate pairs
--
SELECT b1.playerID, b1.nameCommon, GROUP_CONCAT(b2.playerID), b1.teamID, b1.yearID
  FROM bat_war b1, bat_war b2
  WHERE b1.teamID = b2.teamID          -- same team
    AND b1.yearID = b2.yearID          -- same season
    AND b1.stint = 1 AND b2.stint = 1  -- don't match players to multiple teams per year
    AND b1.playerID != b2.playerID     -- reject self-teammates
  GROUP BY b1.yearID, b1.playerID
  ORDER BY yearID DESC, playerID ASC
 ;

==== Enumerating a Many-to-Many Relationship

-- Every stadium a player has played in. (We're going to cheat on the detail of
-- multiple stints and credit every player with all stadiums visited by the team
-- of his first stint in a season
--

-- there are only a few many-to-many cases, so the 89583 seasons in batting
-- table expands to only 91904 player-park-years. But it's a cross product, so
-- beware.
SELECT COUNT(*) FROM batting bat WHERE bat.stint = 1;
SELECT bat.playerID, bat.teamID, bat.yearID, pty.parkID
  FROM       batting bat
  INNER JOIN park_team_years pty
    ON bat.yearID = pty.yearID AND bat.teamID = pty.teamID
  WHERE bat.stint = 1
  ORDER BY playerID
  ;

--
-- What if you only want the distinct player-team-years?
-- You might naively do a join and then a group by,
-- or a join and then distinct. Don't do that.

-- DON'T DO THE (pig equivalent) OF THIS to find the distinct teams, years and parks;
-- it's an extra reduce.
SELECT bat.playerID, bat.nameCommon,
    GROUP_CONCAT(DISTINCT pty.parkID) AS parkIDs, COUNT(DISTINCT pty.parkID) AS n_parks,
    GROUP_CONCAT(DISTINCT bat.teamID) AS teamIDs,
    MIN(bat.yearID) AS begYear, MAX(bat.yearID) AS endYear
  FROM       bat_war bat
  INNER JOIN park_team_years pty
    ON bat.yearID = pty.yearID AND bat.teamID = pty.teamID
  WHERE bat.stint = 1 AND playerID IS NOT NULL
  GROUP BY playerID
  HAVING begYear > 1900
  ORDER BY n_parks DESC, playerID ASC
  ;

--
-- So now we disclose the most important thing that SQL experts need to break
-- their brains of:
--
-- In SQL, the JOIN is supreme.
-- In Pig, the GROUP is supreme
--
-- A JOIN is, for the most part, just sugar around a COGROUP-and-FLATTEN.
-- Very often you'll find the simplest path is through COGROUP not JOIN.
--
-- In this case, if you start by thinkingn of the group, you'll see you can eliminate a whole reduce.
--
-- (show pig, including a DISTINCT in the fancy-style FOREACH)

==== Join Against Another Table Without Discarding Non-Matches

using a left join so you can fix up remnants
note: haven't actually run this, need to load geonames

----
SELECT pk.*
  FROM      parks pk
  LEFT JOIN geonames.places gn
    ON (pk.city = gn.city AND pk.state = gn.region1)
    OR (pk.parkname = gn.placename)
;
----

-- See advanced joins: bag left outer join from DataFu
-- See advanced joins: Left outer join on three tables: http://datafu.incubator.apache.org/docs/datafu/guide/more-tips-and-tricks.html
-- See Time-series: Range query using cross
-- See Time-series: Range query using prefix and UDFs
-- See advanced joins: Sparse joins for filtering, with a HashMap (replicated)
-- Out of scope: Bitmap index
-- Out of scope: Bloom filter joins
-- See time-series: Self-join for successive row differences

==== Find rows with a match in another table (semi-join)

Semi-join: just care about the match, don't keep joined table; anti-join is where you keep the non-matches and also don't keep the joined table. Again, use left or right so that the small table occurs first in the list. Note that a semi-join has only one row per row in dominant table -- so needs to be a cogroup and sum or a join to distinct'ed table (extra reduce, but lets you do a fragment replicate join.)

Select player seasons where they made the all-star team.
You might think you could do this with a join:

----
-- Don't do this... produces duplicates!
bats_g    = JOIN allstar BY (playerID, yearID), bats BY (playerID, yearID);
bats_as   = FOREACH bats_g GENERATE bats::playerID .. bats::HR;
----

The result is wrong, and even a diligent spot-check will probably fail to notice. You see, from 1959-1962 there were multiple All-Star games (!), and so each singular row in the `bat_season` table became two rows in the result for players in those years.

Instead, use a `COGROUP` and filter:

----
ast     = FOREACH allstar GENERATE playerID, yearID;
bats_g  = COGROUP ast     BY (playerID, yearID), bats BY (playerID, yearID);
bats_f  = FILTER  bats_g  BY NOT IsEmpty(ast);
bats_as = FOREACH bats_f  GENERATE FLATTEN(bats);
----

In our case there was only one row per player/year, but in the general case where the dominant table has more than one row for a key, the `FLATTEN` operation will generate just that many rows in the output.

To finding rows with no match in another table -- known as an anti-join -- simply use `FILTER BY IsEmpty()` instead of `FILTER BY NOT IsEmpty()`


==== Counting on multiple levels

-- fraction of people with multiple stints per year (about 7%)

-- don't do this (needs two group-bys):
SELECT n_seasons, COUNT(*), COUNT(*)/n_seasons
  FROM (SELECT COUNT(*) AS n_seasons FROM batting) t1,
  (SELECT COUNT(*) AS n_stints FROM batting GROUP BY playerID, yearID HAVING n_stints > 1) stintful
  ;
-- instead use the summing trick (needs only one group-by):
SELECT COUNT(*), (COUNT(*)-SUM(IF(stint = 1, 1, 0)))/COUNT(*), COUNT(*) FROM batting WHERE stint <= 2;

==== Cube and rollup
-- stats by team, division and league
=== Handling duplicates

==== Eliminating Duplicates from a Table

-- Every team a player has played for
SELECT DISTINCT playerID, teamID from batting;

==== Eliminating Duplicates from a Query Result:

--
-- All parks a team has played in
--
SELECT teamID, GROUP_CONCAT(DISTINCT parkID ORDER BY parkID) AS parkIDs
  FROM park_team_years
  GROUP BY teamID
  ORDER BY teamID, parkID DESC
  ;

==== Identifying unique records for a key

-- * Distinct: players with a unique first name (once again we urge you: crawl through your data. Big data is a collection of stories; the power of its unusual effectiveness mode comes from the comprehensiveness of those stories. even if you aren't into baseball this celebration of the diversity of our human race and the exuberance of identity should fill you with wonder.)
--
-- But have you heard recounted the storied diamond exploits of Firpo Mayberry,
-- Zoilo Versalles, Pi Schwert or Bevo LeBourveau?  OK, then how about
-- Mysterious Walker, The Only Nolan, or Phenomenal Smith?  Mul Holland, Sixto
-- Lezcano, Welcome Gaston or Mox McQuery?  Try asking your spouse to that your
-- next child be named for Urban Shocker, Twink Twining, Pussy Tebeau, Bris Lord, Boob
-- Fowler, Crazy Schmit, Creepy Crespi, Cuddles Marshall, Vinegar Bend Mizell,
-- or Buttercup Dickerson.
--

SELECT nameFirst, nameLast, COUNT(*) AS n_usages
  FROM bat_career
  WHERE    nameFirst IS NOT NULL
  GROUP BY nameFirst
  HAVING   n_usages = 1
  ORDER BY nameFirst
  ;
* Counting Missing Values
* Counting and Identifying Duplicates
* Determining Whether Values are Unique

==== Identifying duplicated records for a key

-- group by, then emit bags with more than one size; call back to the won-loss example

Once again, what starts out looking like one of the high-level operations turns into a GROUP BY.

Up above, the allstar table almost led us astray due to the little-known fact that some years featured multiple All-Star games. We can pull out the rows matching those fields:



-- Teams who played in more than one stadium in a year
SELECT COUNT(*) AS n_parks, pty.*
  FROM park_team_years pty
  GROUP BY teamID, yearID
  HAVING n_parks > 1
==== Eliminating rows that have a duplicated value

 (ie the whole row isn't distinct,
-- just the field you're distinct-ing on.
-- Note: this chooses an arbitrary value from each group
SELECT COUNT(*) AS n_asg, ast.*
  FROM allstarfull ast
  GROUP BY yearID, playerID
  HAVING n_asg > 1
  ;


=== Set Operations

-- Partition a Set into Subsets: SPLIT, but keep in mind that the SPLIT operation doesn't short-circuit.
-- Find the Union of Sets UNION-then-DISTINCT
--    (note that it doesn't dedupe, doesn't order, and doesn't check for same schema)
--    * don't combine the career stats tables by union-group; do it with cogroup.
-- Prepare a Distinct Set from a Collection of Records: DISTINCT
-- Intersect: semi-join (allstars)
-- * Difference (in a but not in b): cogroup keep only empty (non-allstars)
-- * Equality (use symmetric difference): result should be empty
-- * Symmetric difference: in A or B but not in A intersect B -- do this with aggregation: count 0 or 1 and only keep 1
-- * http://datafu.incubator.apache.org/docs/datafu/guide/set-operations.html
-- * http://www.cs.tufts.edu/comp/150CPA/notes/Advanced_Pig.pdf

=== Structural Group Operations (ie non aggregating)

--
-- * GROUP/COGROUP To Restructure Tables
-- * Group Elements From Multiple Tables On A Common Attribute (COGROUP)
-- * Denormalize Normalized
--   - roll up stints
--   - Normalize Denormalized (flatten)



==== Group flatten regroup

--     * OPS+ -- group on season, normalize, reflatten
--     * player's highest OPS+: season, normalize, flatten, group on player, top





==== Generate a won-loss record

footnote:[we're skipping some details such as forfeited games, so the numbers won't agree precisely with the combined team numbers.]

----
-- generate a summable value for each game, once for home and once for away:
home_games = FOREACH games GENERATE
  home_teamID AS teamID, yearID,
  IF (home_runs_ct > away_runs_ct, 1,0) AS win,
  IF (home_runs_ct < away_runs_ct, 1,0) AS loss
  ;
away_games = FOREACH games GENERATE
  away_teamID AS teamID, yearID,
  IF (home_runs_ct < away_runs_ct, 1,0) AS win,
  IF (home_runs_ct > away_runs_ct, 1,0) AS loss
  ;
----

Now you might be tempted (especially if you are coming from SQL land) to follow this with a UNION of `home_games` and `away_games`. Don't! Instead, use a COGROUP. Once you've wrapped your head around it, it's simpler and more efficient.

----
team_games = COGROUP home_games BY (teamID, yearID), away_games BY (teamID, yearID);
----

Each combination of team and year creates one row with the following fields:

* `group`, a tuple with the `teamID` and `yearID`
* `home_games`, a bag holding tuples with `teamID`, `yearID`, `win` and `loss`
* `away_games`, a bag holding tuples with `teamID`, `yearID`, `win` and `loss`

----
team_games:
((BOS,2004),  {(BOS,2004,1,0),(BOS,2004,1,0),...}, {(BOS,2004,0,1),(BOS,2004,1,0),...})
...
----

You should notice a few things:

* The group values go in a single field (the first one) called `group`.
* Since we grouped on two fields, the group value is a tuple; if we had grouped on one field it would have the same schema as that field
* The name of the _table_ in the COGROUP BY statement became the name of the _field_ in the result
* The group values appear redundantly in each tuple of the bag. That's OK, we're about to project them out.

The next step is to calculate the answer:

----
winloss_record = FOREACH team_games {
  wins   = SUM(home_games.win)    + SUM(away_games.win);
  losses = SUM(home_games.loss)   + SUM(away_games.loss);
  G      = COUNT_STAR(home_games) + COUNT_STAR(away_games);
  G_home = COUNT_STAR(home_games);
  ties   = G - (wins + losses);
  GENERATE group.teamID, group.yearID, G, G_home, wins, losses, ties;
};
----

Exercise: Do this instead with a single GROUP. Hint: the first FOREACH should have a FLATTEN.


=== Sorting Operations


* RANK: Dense, not dense
* Number records with a serial or unique index
  - use rank with (the dense that give each a number)
  - use file name index and row number in mapper (ruby UDF)
* Sorting Subsets of a Table (order inside cogroup)
* Controlling Summary Display Order
* Sorting and NULL Values; Controlling Case Sensitivity of String Sorts
*
Note: ORDER BY is NOT stable; can't guarantee that records with same keys will keep same order
Note about ORDER BY and keys across reducers -- for example, you can't do the sort | uniq trick


-- ==== Season leaders

-- * Selecting top-k Records within Group
-- GROUP...FOREACH GENERATE TOP
-- most hr season-by-season

-- ==== Transpose record into attribute-value pairs
--      Group by season, transpose, and take the top 10 for each season, attribute pair


=== Sorting and Ordering Operations

==== Sorting Records by Key


==== Numbering Records by Sorted Rank

--   - ORDER by multiple fields: sort on OPS to three places then use games then playerid
--   - note value of stabilizing list
-- - (how do NULLs sort?)
-- - ASC / DESC: fewest strikeouts per plate appearance


==== Finding Values Associated with Maximum Values

-- For each season by a player, select the team they played the most games for.
-- In SQL, this is fairly clumsy (involving a self-join and then elimination of
-- ties) In Pig, we can ORDER BY within a foreach and then pluck the first
-- element of the bag.

SELECT bat.playerID, bat.yearID, bat.teamID, MAX(batmax.Gmax), MAX(batmax.stints), MAX(teamIDs), MAX(Gs)
  FROM       batting bat
  INNER JOIN (SELECT playerID, yearID, COUNT(*) AS stints, MAX(G) AS Gmax, GROUP_CONCAT(teamID) AS teamIDs, GROUP_CONCAT(G) AS Gs FROM batting bat GROUP BY playerID, yearID) batmax
  ON bat.playerID = batmax.playerID AND bat.yearID = batmax.yearID AND bat.G = batmax.Gmax
  GROUP BY playerID, yearID
  -- WHERE stints > 1
  ;

-- About 7% of seasons have more than one stint; only about 2% of seasons have
-- more than one stint and more than a half-season's worth of games
SELECT COUNT(*), SUM(mt1stint), SUM(mt1stint)/COUNT(*) FROM (SELECT playerID, yearID, IF(COUNT(*) > 1 AND SUM(G) > 77, 1, 0) AS mt1stint FROM batting GROUP BY playerID, yearID) bat

-- TOP(topN, sort_column_idx, bag_of_tuples)
-- must have an explicit field -- can't use an expression

Leaderboard By Season-and-league

-- GROUP BY yearID, lgID

-- There is no good way to find the tuples associated with the minimum value.
-- EXERCISE: make a "BTM" UDF, having the same signature as the "TOP" operation,
-- to return the lowest-n tuples from a bag.

==== Top K Records within a table using ORDER..LIMIT

--      Most hr in a season
--      Describe pigs optimization of order..limit

* Pulling a Section from the Middle of a Result Set: rank and filter? Modify the quantile/median code?

* Hard in SQL but easy in Pig: Finding Rows Containing Per-Group Minimum or Maximum Value, Displaying One Set of Values While Sorting by Another:
--  - can only ORDER BY an explicit field. In SQL you can omit the sort expression from the table (use expression to sort by)
* Sorting a Result Set (when can you count on reducer order?)

====  Shuffle a set of records

See notes on random numbers.


You might also enjoy the random number table, holding 350 million 64-bit numbers directly from random.org (7 GB of 20-digit decimal numbers)
* 160-bit numbers in hexadecimal form
* 32 64-bit numbers (2048-bits per row)



--
-- TODO
--
-- cogroup events by teamID
-- ... there's a way to do this in one less reduce in M/R -- can you in Pig?




=== SQL-to-Pig-to-Hive Cheatsheet

* SELECT..WHERE
* SELECT...LIMit
* GROUP BY...HAVING
* SELECT WHERE... ORDER BY
* SELECT WHERE... SORT BY (just use reducer sort) ~~ (does reducer in Pig guarantee this?)
* SELECT … DISTRIBUTE BY … SORT BY ...
* SELECT ... CLUSTER BY (equiv of distribute by X sort by X)
* Indexing tips
* CASE...when...then
* Block Sampling / Input pruning
* SELECT country_name, indicator_name, `2011` AS trade_2011 FROM wdi WHERE (indicator_name = 'Trade (% of GDP)' OR indicator_name = 'Broad money (% of GDP)') AND `2011` IS NOT NULL CLUSTER BY indicator_name;

SELECT columns or computations FROM table WHERE condition GROUP BY columns HAVING condition ORDER BY column  [ASC | DESC] LIMIT offset,count;



// ------------- CRUFT -------------------------
// ------------- CRUFT -------------------------
// ------------- CRUFT -------------------------
// ------------- CRUFT -------------------------

// Ignore below.



=== In statistics Chapter

==== Cube and rollup
stats by team, division and league

TODO

cogroup events by teamID
... there's a way to do this in one less reduce in M/R -- can you in Pig?

==== in Time-series chapter

* Running total http://en.wikipedia.org/wiki/Prefix_sum
* prefix sum value; by combining list ranking, prefix sums, and Euler tours, many important problems on trees may be solved by efficient parallel algorithms.[3]
* Self join of table on its next row (eg timeseries at regular sample)

--
=== Don't know how to do these

--
-- * Computing Team Standings
-- * Producing Master-Detail Lists and Summaries
-- * Find Overlapping Rows
-- * Find Gaps in Time-Series
-- * Find Missing Rows in Series / Count all Values
-- * Calculating Differences Between Successive Rows
-- * Finding Cumulative Sums and Running Averages

-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--
-- == Tables
--
-- * `games`
--
-- * `events`: the amazing Retrosheet project has _play-by-play_ information for
--   nearly every game since the 1970s. By the time
--
-- * `pitchfx`: a true reminder that we live in the future, Major League
--   Baseball makes available the trajectory of every pitch from every game with
--   full game state since 2007.
--
-- * `allstarfull` table: About halfway through a season, players with a particularly strong
--   performance (or fanbase) are elected to the All-Star game.
--
-- * `halloffame` table: Players with exceptionally strong careers (or particularly strong fanbase
--   among old white journalists) are elected to the Hall of Fame (hof).
--
--
-- * playerID: unique identifier for each player, built from their name and an ascending index
-- * teamID: three-letter unique identifier for a team
-- * parkID: five-letter unique identifier for a park (stadium)
-- * G (Games): the number of
